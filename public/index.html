<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>aiChat</title>
    <script src="js/purify.min.js"></script>
    <link rel="stylesheet" href="css/default.css">
    <link rel="stylesheet" href="css/github-dark.css" media="(prefers-color-scheme: dark)">
    <script src="js/highlight.min.js"></script>
    <script src="js/api-client.js"></script>
    <link rel="stylesheet" href="css/styles.css">
    <style>
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <!-- Conversation History Sidebar -->
      <aside class="conversation-sidebar" id="conversationSidebar">
        <div class="sidebar-button-row">
          <button class="new-chat-btn" id="newChatBtn" aria-label="Start a new conversation" title="Start new chat">‚úö</button>
          <button class="sidebar-collapse-btn" id="sidebarCollapseBtn" aria-label="Collapse sidebar" title="Close chat history">‚Üê</button>
        </div>
        <div class="conversation-search">
          <input type="text" id="conversationSearch" placeholder="Search conversations..." class="search-input">
        </div>
        <div class="conversation-list" id="conversationList">
          <div class="conversation-list-empty" id="conversationListEmpty">
            No conversations yet. Start chatting to create your first conversation!
          </div>
        </div>
        <div class="sidebar-footer">
          <label class="switch">
            <input type="checkbox" id="autoSaveToggle" checked>
            <span class="slider">Auto-save conversations</span>
          </label>
        </div>
      </aside>

      <!-- Main Chat Area -->
      <main class="chat-main">
        <header class="chat-header">
          <div class="header-left">
            <button class="sidebar-toggle-mobile" id="sidebarToggleMobile" aria-label="Toggle conversation history">‚ò∞</button>
            <div class="conversation-title-container">
              <h1 id="conversationTitle"></h1>
            </div>
          </div>
          <nav aria-label="Provider and model selection">
            <div class="provider-controls">
              <label for="providerSelect" class="sr-only">Select AI Provider</label>
              <select class="provider-select" id="providerSelect" aria-label="Select AI provider">
                <option value="">Loading...</option>
              </select>
              <label for="modelSelect" class="sr-only">Select AI Model</label>
              <select class="model-select" id="modelSelect" aria-label="Select AI model">
                <option value="">Select model...</option>
              </select>
            </div>
          </nav>
        </header>
        
        <section id="chatContainer" role="log" aria-live="polite" aria-label="Conversation history">
        </section>

        <form aria-label="Send message">
          <label for="messageInput" class="sr-only">Type your message</label>
          <textarea
            class="message-input"
            id="messageInput"
            placeholder="Type your message..."
            rows="1"
            aria-describedby="sendButton"
            required
          ></textarea>
          <button class="send-button" id="sendButton" type="submit" aria-label="Send message">‚û§</button>
        </form>
      </main>
    </div>


    <script>
      // Initialize highlight.js
      hljs.highlightAll();
      
      const chatContainer = document.getElementById("chatContainer");
      const messageInput = document.getElementById("messageInput");
      const sendButton = document.getElementById("sendButton");
      const providerSelect = document.getElementById("providerSelect");
      const modelSelect = document.getElementById("modelSelect");

      // Initialize API client
      const conversationAPI = new ConversationAPI();
      
      // Conversation state
      let currentConversation = null;
      let conversationList = [];
      let autoSaveEnabled = true;
      let conversationHistory = [];
      
      // Provider/model state
      let availableProviders = [];
      let selectedProvider = null;
      let selectedModel = null;
      
      // UI elements
      const conversationSidebar = document.getElementById("conversationSidebar");
      const conversationListEl = document.getElementById("conversationList");
      const conversationTitle = document.getElementById("conversationTitle");
      const newChatBtn = document.getElementById("newChatBtn");
      const sidebarCollapseBtn = document.getElementById("sidebarCollapseBtn");
      const sidebarToggleMobile = document.getElementById("sidebarToggleMobile");
      const autoSaveToggle = document.getElementById("autoSaveToggle");
      const conversationSearch = document.getElementById("conversationSearch");

      // Auto-resize textarea
      messageInput.addEventListener("input", function () {
        this.style.height = "auto";
        this.style.height = Math.min(this.scrollHeight, 120) + "px";
      });

      // Send message on Enter (but allow Shift+Enter for new lines)
      messageInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      // Send button click handler and form submission
      sendButton.addEventListener("click", function(e) {
        e.preventDefault();
        sendMessage();
      });
      
      // Handle form submission
      document.querySelector('form').addEventListener('submit', function(e) {
        e.preventDefault();
        sendMessage();
      });

      function addMessage(content, type = "user", metadata = null) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${type}`;
        
        if (type === "assistant" && metadata) {
          // Create content with provider info
          const contentDiv = document.createElement("div");
          contentDiv.innerHTML = DOMPurify.sanitize(content);
          
          const providerInfo = document.createElement("div");
          providerInfo.className = "provider-info";
          providerInfo.textContent = `${metadata.providerName} ‚Ä¢ ${metadata.model}`;
          
          messageDiv.appendChild(contentDiv);
          messageDiv.appendChild(providerInfo);
        } else {
          messageDiv.innerHTML = DOMPurify.sanitize(content);
        }

        chatContainer.appendChild(messageDiv);
        
        // Apply syntax highlighting to any new code blocks
        if (type === "assistant") {
          hljs.highlightAll();
        }
        
        scrollToBottom();
      }

      function addError(message) {
        const errorDiv = document.createElement("div");
        errorDiv.className = "error";
        errorDiv.textContent = message;

        chatContainer.appendChild(errorDiv);
        scrollToBottom();
      }

      function scrollToBottom() {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function addSkeletonMessage() {
        const skeletonDiv = document.createElement("div");
        skeletonDiv.className = "message skeleton";
        skeletonDiv.id = "skeleton-message";
        skeletonDiv.setAttribute("role", "status");
        skeletonDiv.setAttribute("aria-live", "polite");
        skeletonDiv.setAttribute("aria-label", "AI is responding");
        
        skeletonDiv.innerHTML = `
          <div class="skeleton-content">
            <div class="skeleton-thinking-text">AI is thinking...</div>
            <div class="skeleton-line skeleton-line-long"></div>
            <div class="skeleton-line skeleton-line-medium"></div>
            <div class="skeleton-line skeleton-line-short"></div>
          </div>
          <div class="message-content" style="display: none;"></div>
        `;
        
        chatContainer.appendChild(skeletonDiv);
        scrollToBottom();
      }

      function transformSkeletonToMessage(content, metadata = null) {
        const skeletonMessage = document.getElementById("skeleton-message");
        if (!skeletonMessage) return null;
        
        const skeletonContent = skeletonMessage.querySelector('.skeleton-content');
        const messageContent = skeletonMessage.querySelector('.message-content');
        
        // Prepare the actual message content
        if (metadata) {
          // Create content with provider info
          const contentDiv = document.createElement("div");
          contentDiv.innerHTML = DOMPurify.sanitize(content);
          
          const providerInfo = document.createElement("div");
          providerInfo.className = "provider-info";
          providerInfo.textContent = `${metadata.providerName} ‚Ä¢ ${metadata.model}`;
          
          messageContent.appendChild(contentDiv);
          messageContent.appendChild(providerInfo);
        } else {
          messageContent.innerHTML = DOMPurify.sanitize(content);
        }
        
        // Show the message content
        messageContent.style.display = 'block';
        
        // Start the transition
        skeletonContent.classList.add('fade-out');
        
        setTimeout(() => {
          messageContent.classList.add('fade-in');
          // Remove skeleton class and update attributes
          skeletonMessage.classList.remove('skeleton');
          skeletonMessage.className = 'message assistant';
          skeletonMessage.removeAttribute('role');
          skeletonMessage.removeAttribute('aria-live');
          skeletonMessage.removeAttribute('aria-label');
          skeletonMessage.removeAttribute('id');
          
          // Apply syntax highlighting to any new code blocks
          hljs.highlightAll();
          
          // Remove skeleton content after transition
          setTimeout(() => {
            if (skeletonContent) {
              skeletonContent.remove();
            }
          }, 300);
        }, 150); // Small delay for better visual timing
        
        return skeletonMessage;
      }

      function removeSkeletonMessage() {
        const skeletonMessage = document.getElementById("skeleton-message");
        if (skeletonMessage) {
          skeletonMessage.remove();
        }
      }

      function setLoading(isLoading) {
        sendButton.disabled = isLoading;
        messageInput.disabled = isLoading;

        if (isLoading) {
          sendButton.textContent = "‚è≥";
          addSkeletonMessage();
        } else {
          sendButton.textContent = "‚û§";
          removeSkeletonMessage();
        }
      }

      async function sendMessage() {
        const message = messageInput.value.trim();

        if (!message) {
          return;
        }

        // Remember if this is the first message for title generation
        const isFirstMessage = conversationHistory.length === 0;
        const firstUserMessage = isFirstMessage ? message : null;

        // Create conversation if needed
        if (!currentConversation && autoSaveEnabled) {
          currentConversation = await createNewConversation();
          if (!currentConversation) {
            // Failed to create conversation, continue without persistence
            console.warn('Continuing without persistence due to conversation creation failure');
          }
        }

        // Add user message to conversation history
        conversationHistory.push({ role: "user", content: message });

        // Add user message to chat display
        addMessage(message, "user");

        // Save user message to database if we have a conversation
        if (currentConversation && autoSaveEnabled) {
          try {
            await conversationAPI.saveMessage(currentConversation.id, "user", message);
          } catch (error) {
            console.warn('Failed to save user message:', error);
          }
        }

        // Clear input and reset height
        messageInput.value = "";
        messageInput.style.height = "auto";

        // Set loading state
        setLoading(true);

        try {
          let data;
          
          if (currentConversation && autoSaveEnabled) {
            // Use the persistence-aware API
            data = await conversationAPI.sendMessageWithPersistence(
              currentConversation.id,
              conversationHistory,
              selectedProvider,
              selectedModel
            );
          } else {
            // Fall back to direct chat API
            const response = await fetch("/api/chat", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ 
                messages: conversationHistory,
                provider: selectedProvider,
                model: selectedModel
              }),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            data = await response.json();
          }

          // Add assistant response to chat
          if (data.response) {
            // Add to conversation history
            conversationHistory.push({
              role: "assistant",
              content: data.response,
            });

            // Transform skeleton to actual message with provider metadata
            transformSkeletonToMessage(data.response, {
              providerName: data.providerName,
              model: data.model
            });

            // Generate title after first response
            if (firstUserMessage && currentConversation) {
              await generateAndSetTitle(firstUserMessage);
            }

            // Update conversation list (conversation was modified)
            if (currentConversation) {
              refreshConversationList();
            }
          } else {
            throw new Error("No response received from server");
          }
        } catch (error) {
          console.error("Error sending message:", error);
          addError(`Error: ${error.message}`);

          // Remove the failed user message from history
          conversationHistory.pop();
        } finally {
          setLoading(false);
          messageInput.focus();
        }
      }

      function clearConversation() {
        // Reset conversation state
        currentConversation = null;
        conversationHistory = [];
        
        // Clear chat display
        chatContainer.innerHTML = '';
        
        // Update UI - no title initially
        conversationTitle.textContent = "";
        updateConversationListUI();
        
        // Focus input
        messageInput.focus();
      }

      // Conversation management functions
      async function createNewConversation() {
        try {
          // Create conversation without title initially
          const conversation = await conversationAPI.createConversation("Untitled");
          currentConversation = conversation;
          
          // Don't set title yet - it will be set after first response
          refreshConversationList();
          
          return conversation;
        } catch (error) {
          console.error('Failed to create conversation:', error);
          showError('Failed to create new conversation');
          return null;
        }
      }

      // Generate and set conversation title after first response
      async function generateAndSetTitle(firstMessage) {
        if (!currentConversation || !firstMessage) return;
        
        try {
          const titleResponse = await conversationAPI.generateTitle(
            firstMessage, 
            selectedProvider, 
            selectedModel
          );
          
          if (titleResponse.title) {
            // Update the conversation title
            await updateConversationTitle(currentConversation.id, titleResponse.title);
          }
        } catch (error) {
          console.warn('Failed to generate title:', error);
          // Fallback to a simple title
          await updateConversationTitle(currentConversation.id, "Chat");
        }
      }

      async function loadConversation(conversationId) {
        try {
          showConversationLoader();
          
          const conversation = await conversationAPI.getConversation(conversationId);
          currentConversation = conversation;
          
          // Load messages into UI
          conversationHistory = conversation.messages || [];
          
          // Clear and rebuild chat display
          chatContainer.innerHTML = '';
          
          if (conversationHistory.length === 0) {
            // Leave chat container empty for new conversations
          } else {
            conversationHistory.forEach(msg => {
              const metadata = msg.provider && msg.model ? {
                providerName: msg.provider,
                model: msg.model
              } : null;
              addMessage(msg.content, msg.role, metadata);
            });
          }
          
          // Update UI
          conversationTitle.textContent = conversation.title;
          updateConversationListUI();
          
          hideConversationLoader();
        } catch (error) {
          console.error('Failed to load conversation:', error);
          showError('Failed to load conversation');
          hideConversationLoader();
        }
      }


      async function updateConversationTitle(id, newTitle) {
        try {
          await conversationAPI.updateConversationTitle(id, newTitle);
          if (currentConversation && currentConversation.id === id) {
            currentConversation.title = newTitle;
            conversationTitle.textContent = newTitle;
          }
          refreshConversationList();
        } catch (error) {
          console.error('Failed to update conversation title:', error);
          showError('Failed to update title');
        }
      }

      async function deleteConversation(id) {
        if (!confirm('Are you sure you want to delete this conversation?')) return;
        
        try {
          await conversationAPI.deleteConversation(id);
          
          // If we're deleting the current conversation, clear it
          if (currentConversation && currentConversation.id === id) {
            clearConversation();
          }
          
          refreshConversationList();
          showSuccess('Conversation deleted');
        } catch (error) {
          console.error('Failed to delete conversation:', error);
          showError('Failed to delete conversation');
        }
      }

      async function refreshConversationList() {
        try {
          const data = await conversationAPI.listConversations(50, 0);
          conversationList = data.conversations || [];
          updateConversationListUI();
        } catch (error) {
          console.error('Failed to refresh conversation list:', error);
        }
      }

      function updateConversationListUI() {
        const emptyState = document.getElementById('conversationListEmpty');
        
        if (conversationList.length === 0) {
          emptyState.style.display = 'block';
          conversationListEl.innerHTML = '';
          conversationListEl.appendChild(emptyState);
          return;
        }
        
        emptyState.style.display = 'none';
        conversationListEl.innerHTML = '';
        
        conversationList.forEach(conversation => {
          const item = createConversationListItem(conversation);
          conversationListEl.appendChild(item);
        });
      }

      function createConversationListItem(conversation) {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        if (currentConversation && currentConversation.id === conversation.id) {
          item.classList.add('active');
        }
        
        item.innerHTML = `
          <div class="conversation-title">${ConversationUtils.truncateText(conversation.title, 40)}</div>
          <div class="conversation-meta">
            <span>${ConversationUtils.formatConversationDate(conversation.updatedAt)}</span>
            <span>${conversation.messageCount || 0} messages</span>
          </div>
          <div class="conversation-actions">
            <button class="action-btn delete-btn" data-id="${conversation.id}" title="Delete">üóë</button>
          </div>
        `;
        
        // Add click handler for loading conversation
        item.addEventListener('click', (e) => {
          if (!e.target.classList.contains('action-btn')) {
            loadConversation(conversation.id);
          }
        });
        
        // Add handlers for action buttons
        
        item.querySelector('.delete-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteConversation(conversation.id);
        });
        
        return item;
      }


      // Provider/model selection functions
      async function loadProviders() {
        try {
          const response = await fetch("/api/providers");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          availableProviders = data.providers || [];
          
          // Populate provider dropdown
          providerSelect.innerHTML = "";
          if (availableProviders.length === 0) {
            providerSelect.innerHTML = '<option value="">No providers available</option>';
            return;
          }
          
          availableProviders.forEach(provider => {
            const option = document.createElement("option");
            option.value = provider.id;
            option.textContent = provider.name;
            providerSelect.appendChild(option);
          });
          
          // Set default provider
          if (data.default && availableProviders.length > 0) {
            selectedProvider = data.default;
            providerSelect.value = selectedProvider;
            loadModelsForProvider(selectedProvider);
          }
          
        } catch (error) {
          console.error("Error loading providers:", error);
          providerSelect.innerHTML = '<option value="">Error loading providers</option>';
        }
      }
      
      function loadModelsForProvider(providerId) {
        const provider = availableProviders.find(p => p.id === providerId);
        if (!provider) return;
        
        // Clear and populate model dropdown
        modelSelect.innerHTML = "";
        provider.models.forEach(model => {
          const option = document.createElement("option");
          option.value = model;
          option.textContent = model;
          modelSelect.appendChild(option);
        });
        
        // Set default model
        selectedModel = provider.defaultModel;
        modelSelect.value = selectedModel;
        
      }
      
      
      // Provider selection change handler
      providerSelect.addEventListener("change", function() {
        selectedProvider = this.value;
        if (selectedProvider) {
          loadModelsForProvider(selectedProvider);
          saveUserSelection();
        }
      });
      
      // Model selection change handler
      modelSelect.addEventListener("change", function() {
        selectedModel = this.value;
        saveUserSelection();
      });
      
      // LocalStorage persistence
      function saveUserSelection() {
        if (selectedProvider && selectedModel) {
          localStorage.setItem("preferredProvider", selectedProvider);
          localStorage.setItem("preferredModel", selectedModel);
        }
      }
      
      function loadUserSelection() {
        const savedProvider = localStorage.getItem("preferredProvider");
        const savedModel = localStorage.getItem("preferredModel");
        
        if (savedProvider && savedModel) {
          // Check if saved provider is still available
          const provider = availableProviders.find(p => p.id === savedProvider);
          if (provider && provider.models.includes(savedModel)) {
            selectedProvider = savedProvider;
            selectedModel = savedModel;
            providerSelect.value = savedProvider;
            loadModelsForProvider(savedProvider);
            modelSelect.value = savedModel;
              }
        }
      }

      // UI Event Handlers
      newChatBtn.addEventListener('click', clearConversation);
      

      function toggleSidebarCollapse() {
        conversationSidebar.classList.toggle('collapsed');
        const isCollapsed = conversationSidebar.classList.contains('collapsed');
        
        // Update tooltip text based on state
        sidebarCollapseBtn.title = isCollapsed ? 'Open chat history' : 'Close chat history';
        
        localStorage.setItem('sidebarCollapsed', isCollapsed);
      }

      sidebarCollapseBtn.addEventListener('click', toggleSidebarCollapse);

      sidebarToggleMobile.addEventListener('click', () => {
        conversationSidebar.classList.toggle('open');
        // Add overlay for mobile
        let overlay = document.querySelector('.sidebar-overlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'sidebar-overlay';
          document.body.appendChild(overlay);
          overlay.addEventListener('click', () => {
            conversationSidebar.classList.remove('open');
            overlay.classList.remove('show');
          });
        }
        overlay.classList.toggle('show', conversationSidebar.classList.contains('open'));
      });

      autoSaveToggle.addEventListener('change', (e) => {
        autoSaveEnabled = e.target.checked;
        localStorage.setItem('autoSaveEnabled', autoSaveEnabled);
      });


      conversationSearch.addEventListener('input', (e) => {
        filterConversations(e.target.value);
      });

      // Helper functions for UI feedback
      function showError(message, duration = 5000) {
        // Create or update error element
        let errorEl = document.querySelector('.app-error');
        if (!errorEl) {
          errorEl = document.createElement('div');
          errorEl.className = 'app-error';
          errorEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md) var(--spacing-lg);
            z-index: 10000;
            max-width: 300px;
          `;
          document.body.appendChild(errorEl);
        }
        
        errorEl.textContent = message;
        errorEl.style.display = 'block';
        
        setTimeout(() => {
          errorEl.style.display = 'none';
        }, duration);
      }

      function showSuccess(message, duration = 3000) {
        // Create or update success element
        let successEl = document.querySelector('.app-success');
        if (!successEl) {
          successEl = document.createElement('div');
          successEl.className = 'app-success';
          successEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: var(--radius-md);
            padding: var(--spacing-md) var(--spacing-lg);
            z-index: 10000;
            max-width: 300px;
          `;
          document.body.appendChild(successEl);
        }
        
        successEl.textContent = message;
        successEl.style.display = 'block';
        
        setTimeout(() => {
          successEl.style.display = 'none';
        }, duration);
      }

      function showConversationLoader() {
        const loader = document.createElement('div');
        loader.id = 'conversationLoader';
        loader.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--text-secondary);
        `;
        loader.textContent = 'Loading conversation...';
        chatContainer.style.position = 'relative';
        chatContainer.appendChild(loader);
      }

      function hideConversationLoader() {
        const loader = document.getElementById('conversationLoader');
        if (loader) {
          loader.remove();
        }
      }

      function showSaveIndicator() {
        // Brief visual feedback for save operations
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          position: fixed;
          bottom: 100px;
          right: 20px;
          background: var(--primary-color);
          color: white;
          padding: var(--spacing-xs) var(--spacing-md);
          border-radius: var(--radius-md);
          font-size: 12px;
          z-index: 1000;
          opacity: 0.8;
        `;
        indicator.textContent = 'Saved';
        document.body.appendChild(indicator);
        
        setTimeout(() => {
          indicator.remove();
        }, 1000);
      }

      function filterConversations(query) {
        if (!query.trim()) {
          updateConversationListUI();
          return;
        }
        
        const filtered = conversationList.filter(conv => 
          conv.title.toLowerCase().includes(query.toLowerCase())
        );
        
        // Temporarily update the conversation list
        const originalList = conversationList;
        conversationList = filtered;
        updateConversationListUI();
        conversationList = originalList;
      }

      // Load saved settings
      function loadSavedSettings() {
        // Load auto-save setting
        const savedAutoSave = localStorage.getItem('autoSaveEnabled');
        if (savedAutoSave !== null) {
          autoSaveEnabled = savedAutoSave === 'true';
          autoSaveToggle.checked = autoSaveEnabled;
        }

        // Load sidebar collapse state
        const sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
        if (sidebarCollapsed) {
          conversationSidebar.classList.add('collapsed');
        }
        
        // Set initial tooltip text
        sidebarCollapseBtn.title = sidebarCollapsed ? 'Open chat history' : 'Close chat history';
      }

      // Initialize app
      async function initializeApp() {
        try {
          loadSavedSettings();
          await loadProviders();
          loadUserSelection();
          await refreshConversationList();
          messageInput.focus();
        } catch (error) {
          console.error('Failed to initialize app:', error);
          showError('Failed to initialize application');
        }
      }

      // Initialize providers on page load
      initializeApp();
    </script>
  </body>
</html>
